<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Game (Fixed)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { transform: scaleX(-1); display: none; }
        canvas { transform: scaleX(-1); width: 100%; height: 100%; object-fit: contain; }
        
        /* UIの配置を個別に設定 */
        #score, #timer { 
            position: absolute; 
            top: 20px; 
            color: #0f0; 
            font-size: 32px; 
            pointer-events: none; 
            text-shadow: 2px 2px 4px #000; 
            z-index: 20; 
        }
        #score { left: 20px; }
        #timer { right: 20px; } /* タイマーを右上に移動 */

        #message { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #ff0; 
            font-size: 32px; 
            text-align: center; 
            pointer-events: none; 
            background: rgba(0,0,0,0.5); 
            padding: 20px; 
            border-radius: 10px; 
            z-index: 10; 
        }
    </style>
</head>
<body>
<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="timer">Time: 60</div>
    <div id="message">カメラ起動中...</div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const scoreElement = document.getElementById('score'), timerElement = document.getElementById('timer'), messageElement = document.getElementById('message');

    // ターゲットの半径を 50 -> 60 (1.2倍) に変更
    let score = 0, gameStarted = false, startTime = 0, lastEndTime = 0, circle = { x: 0, y: 0, radius: 60 }, isReadyToCatch = false, handStates = [{ isTouching: false, wasBent: true }, { isTouching: false, wasBent: true }];
    const cooldownTime = 3000, gameDuration = 60, ringRadius = 60;
    let audioCtx = null;

    function initAudioContext() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function speak(text) {
        window.speechSynthesis.cancel();
        const uttr = new SpeechSynthesisUtterance(text);
        uttr.lang = 'ja-JP';
        window.speechSynthesis.speak(uttr);
    }

    function playCatchSound() {
        initAudioContext();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(700, audioCtx.currentTime);
        osc.start();
        gain.gain.setValueAtTime(1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
        osc.stop(audioCtx.currentTime + 0.12);
    }

    function generateNewCircle() {
        circle.x = Math.random() * (canvasElement.width - 200) + 100;
        circle.y = Math.random() * ((canvasElement.height * 0.875 - 50) - 150) + 150;
        handStates.forEach(s => s.isTouching = false); isReadyToCatch = false;
    }

    function onResults(results) {
        canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight;
        canvasCtx.save(); canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        let targetCaught = false, currentFrameReadyToCatch = false, now = Date.now();
        if (results.multiHandLandmarks) {
            results.multiHandLandmarks.forEach((landmarks, index) => {
                if (index > 1) return;
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                const hx = landmarks[9].x * canvasElement.width, hy = landmarks[9].y * canvasElement.height;
                const isBentNow = Math.hypot(landmarks[9].x - landmarks[12].x, landmarks[9].y - landmarks[12].y) < (Math.hypot(landmarks[0].x - landmarks[9].x, landmarks[0].y - landmarks[9].y) * 0.6);
                canvasCtx.beginPath(); canvasCtx.arc(hx, hy, ringRadius, 0, 2 * Math.PI);
                canvasCtx.strokeStyle = isBentNow ? '#FFF' : '#FF0'; canvasCtx.lineWidth = 6; canvasCtx.stroke();
                if (!gameStarted) {
                    if (now - lastEndTime > cooldownTime && landmarks[9].y < 0.4) {
                        initAudioContext(); gameStarted = true; score = 0; startTime = now; messageElement.style.display = 'none'; speak("スタート"); generateNewCircle();
                    }
                } else {
                    const isTouchingNow = Math.hypot(hx - circle.x, hy - circle.y) < ringRadius;
                    if (isTouchingNow && !isBentNow) currentFrameReadyToCatch = true;
                    if (isTouchingNow && !handStates[index].wasBent && isBentNow) targetCaught = true;
                    handStates[index].isTouching = isTouchingNow; handStates[index].wasBent = isBentNow;
                }
            });
        }
        isReadyToCatch = currentFrameReadyToCatch;
        if (gameStarted) {
            if (targetCaught) { playCatchSound(); score++; generateNewCircle(); }
            const remaining = Math.max(0, gameDuration - Math.floor((now - startTime) / 1000));
            timerElement.innerText = `Time: ${remaining}`; scoreElement.innerText = `Score: ${score}`;
            canvasCtx.save(); canvasCtx.fillStyle = isReadyToCatch ? 'red' : 'green'; if(isReadyToCatch) { canvasCtx.shadowBlur = 35; canvasCtx.shadowColor = "red"; }
            canvasCtx.beginPath(); canvasCtx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI); canvasCtx.fill(); canvasCtx.restore();
            if (remaining <= 0) { gameStarted = false; lastEndTime = now; messageElement.style.display = 'block'; messageElement.innerHTML = `終了！<br>${score}点です`; speak(`${score}点です。終了。`); }
        } else if (now - lastEndTime > cooldownTime) { 
            // メッセージを日本語のみに修正
            messageElement.innerHTML = "どちらかの手を高く上げてください"; 
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);
    const camera = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 1280, height: 720 });
    window.onload = () => camera.start();
    window.addEventListener('click', () => { initAudioContext(); speak(""); }, { once: true });
</script>
</body>
</html>