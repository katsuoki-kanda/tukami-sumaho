<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Game (High Performance)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { display: none; }
        /* canvasの反転はCSSではなくMediaPipeのselfieModeで制御すると計算が楽になります */
        canvas { width: 100%; height: 100%; object-fit: contain; }
        
        #score, #timer { 
            position: absolute; 
            top: 20px; 
            color: #0f0; 
            font-size: 28px; 
            pointer-events: none; 
            text-shadow: 2px 2px 4px #000; 
            z-index: 20; 
        }
        #score { left: 20px; }
        #timer { right: 20px; }

        #message { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #ff0; 
            font-size: 24px; 
            text-align: center; 
            pointer-events: none; 
            background: rgba(0,0,0,0.7); 
            padding: 20px; 
            border-radius: 10px; 
            z-index: 10; 
            width: 80%;
        }
    </style>
</head>
<body>
<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="timer">Time: 60</div>
    <div id="message">カメラを準備中...</div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false }); // パフォーマンス向上のためアルファチャネル無効
    const scoreElement = document.getElementById('score'), 
          timerElement = document.getElementById('timer'), 
          messageElement = document.getElementById('message');

    let score = 0, gameStarted = false, startTime = 0, lastEndTime = 0;
    let circle = { x: 0, y: 0, radius: 60 };
    let isReadyToCatch = false;
    let handStates = [{ isTouching: false, wasBent: true }, { isTouching: false, wasBent: true }];
    
    const cooldownTime = 3000, gameDuration = 60, ringRadius = 60;
    let audioCtx = null;

    // キャンバスサイズの初期化（一度だけ行う）
    function updateCanvasSize() {
        canvasElement.width = 640;
        canvasElement.height = 480;
    }

    function initAudioContext() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function speak(text) {
        window.speechSynthesis.cancel();
        const uttr = new SpeechSynthesisUtterance(text);
        uttr.lang = 'ja-JP';
        window.speechSynthesis.speak(uttr);
    }

    function playCatchSound() {
        initAudioContext();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.start();
        gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.stop(audioCtx.currentTime + 0.12);
    }

    function generateNewCircle() {
        circle.x = Math.random() * (canvasElement.width - 160) + 80;
        circle.y = Math.random() * (canvasElement.height * 0.6) + 100;
        handStates.forEach(s => s.isTouching = false); 
        isReadyToCatch = false;
    }

    function onResults(results) {
        // 描画開始
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        let targetCaught = false;
        let currentFrameReadyToCatch = false;
        const now = Date.now();

        if (results.multiHandLandmarks) {
            for (let index = 0; index < Math.min(results.multiHandLandmarks.length, 2); index++) {
                const landmarks = results.multiHandLandmarks[index];
                
                // 手の描画を簡略化（線のみ）
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                
                const hx = landmarks[9].x * canvasElement.width;
                const hy = landmarks[9].y * canvasElement.height;
                
                // 屈曲判定の計算を最適化
                const dx12 = landmarks[9].x - landmarks[12].x;
                const dy12 = landmarks[9].y - landmarks[12].y;
                const dx09 = landmarks[0].x - landmarks[9].x;
                const dy09 = landmarks[0].y - landmarks[9].y;
                const dist12 = dx12 * dx12 + dy12 * dy12; // 平方根を避けて比較
                const dist09 = dx09 * dx09 + dy09 * dy09;
                const isBentNow = dist12 < (dist09 * 0.36); // 0.6の2乗

                // 操作リングの描画
                canvasCtx.beginPath();
                canvasCtx.arc(hx, hy, ringRadius, 0, 2 * Math.PI);
                canvasCtx.strokeStyle = isBentNow ? '#FFF' : '#FF0';
                canvasCtx.lineWidth = 4;
                canvasCtx.stroke();

                if (!gameStarted) {
                    if (now - lastEndTime > cooldownTime && landmarks[9].y < 0.3) {
                        initAudioContext();
                        gameStarted = true;
                        score = 0;
                        startTime = now;
                        messageElement.style.display = 'none';
                        speak("スタート");
                        generateNewCircle();
                    }
                } else {
                    const distToTarget = Math.hypot(hx - circle.x, hy - circle.y);
                    const isTouchingNow = distToTarget < ringRadius + 20;
                    
                    if (isTouchingNow && !isBentNow) currentFrameReadyToCatch = true;
                    if (isTouchingNow && !handStates[index].wasBent && isBentNow) targetCaught = true;
                    
                    handStates[index].isTouching = isTouchingNow;
                    handStates[index].wasBent = isBentNow;
                }
            }
        }
        
        isReadyToCatch = currentFrameReadyToCatch;

        if (gameStarted) {
            if (targetCaught) { 
                playCatchSound(); 
                score++; 
                generateNewCircle(); 
            }
            const remaining = Math.max(0, gameDuration - Math.floor((now - startTime) / 1000));
            timerElement.innerText = `Time: ${remaining}`;
            scoreElement.innerText = `Score: ${score}`;
            
            // ターゲットの描画
            canvasCtx.fillStyle = isReadyToCatch ? 'red' : 'green';
            if(isReadyToCatch) {
                canvasCtx.shadowBlur = 20;
                canvasCtx.shadowColor = "red";
            }
            canvasCtx.beginPath();
            canvasCtx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
            canvasCtx.fill();
            canvasCtx.shadowBlur = 0; // シャドウをリセット

            if (remaining <= 0) {
                gameStarted = false;
                lastEndTime = now;
                messageElement.style.display = 'block';
                messageElement.innerHTML = `終了！<br>${score}点です`;
                speak(`${score}点です。終了。`);
            }
        } else if (now - lastEndTime > cooldownTime) {
            messageElement.innerHTML = "どちらかの手を高く上げるとスタート！";
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    // パフォーマンス設定
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 0, // 0: Lite (高速), 1: Full
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
        selfieMode: true // カメラ画像をここで反転させる
    });
    
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,  // 解像度を落として負荷軽減
        height: 480
    });

    window.onload = () => {
        updateCanvasSize();
        camera.start();
    };
    
    // モバイルでの音声再生制限解除用
    window.addEventListener('touchstart', () => { 
        initAudioContext();
    }, { once: true });
</script>
</body>
</html>